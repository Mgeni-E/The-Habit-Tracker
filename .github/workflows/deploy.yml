name: Deploy to VM

on:
  workflow_call:
    inputs:
      image:
        required: true
        type: string
    secrets:
      DEPLOY_VM_IP:
        required: true
      DEPLOY_SSH_KEY:
        required: true
      DB_HOST:
        required: true
      DB_PORT:
        required: true
      DB_NAME:
        required: true
      DB_USER:
        required: true
      DB_PASSWORD:
        required: true
      SECRET_KEY:
        required: true
      FLASK_ENV:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    environment: production
    env:
      VM_IP: ${{ secrets.DEPLOY_VM_IP }}
      SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          echo "ğŸ” VM IP: $VM_IP"
          echo "ğŸ” SSH key length: $(echo "$SSH_PRIVATE_KEY" | wc -c) characters"

          if [ -z "$VM_IP" ]; then
            echo "âŒ VM IP is empty. Check DEPLOY_VM_IP secret."
            exit 1
          fi

          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "âŒ SSH private key is empty. Check DEPLOY_SSH_KEY secret."
            exit 1
          fi

          echo "âœ… VM IP: $VM_IP"
          echo "âœ… SSH key length: $(echo "$SSH_PRIVATE_KEY" | wc -c) characters"

          # Setup SSH directory and key
          mkdir -p ~/.ssh

          # Write SSH key with proper formatting
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa

          # Ensure proper permissions
          chmod 600 ~/.ssh/id_rsa
          chmod 700 ~/.ssh

          # Verify key format and add debugging
          echo "ğŸ” Verifying SSH key format..."
          echo "ğŸ” Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "ğŸ” Key starts with: $(head -1 ~/.ssh/id_rsa)"
          echo "ğŸ” Key ends with: $(tail -1 ~/.ssh/id_rsa)"

          if ssh-keygen -l -f ~/.ssh/id_rsa 2>/dev/null; then
            echo "âœ… SSH key format is valid"
          else
            echo "âŒ SSH key format is invalid"
            echo "ğŸ” Full key content (first 5 lines):"
            head -5 ~/.ssh/id_rsa
            echo "ğŸ” Attempting to fix key format..."

            # Try to fix common formatting issues
            sed -i 's/\\n/\n/g' ~/.ssh/id_rsa

            if ssh-keygen -l -f ~/.ssh/id_rsa 2>/dev/null; then
              echo "âœ… SSH key format fixed"
            else
              echo "âŒ Could not fix SSH key format"
              exit 1
            fi
          fi

          # Test SSH connection before proceeding
          echo "ğŸ” Testing SSH connection..."
          if ssh -o ConnectTimeout=10 -o BatchMode=yes vm "echo 'SSH test successful'" 2>/dev/null; then
            echo "âœ… SSH connection test successful"
          else
            echo "âŒ SSH connection test failed"
            echo "ğŸ” Trying verbose SSH connection for debugging..."
            ssh -v -o ConnectTimeout=10 -o BatchMode=yes vm "echo 'SSH test'" 2>&1 | head -20
            exit 1
          fi

          # Create SSH config for better connection handling
          cat > ~/.ssh/config << EOF
          Host vm
            HostName $VM_IP
            User azureuser
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 30
          EOF
          chmod 600 ~/.ssh/config

          echo "âœ… VM is ready (verified by terraform-apply stage)"

      - name: Create deployment environment file
        run: |
          echo "ğŸ” Creating deployment environment file..."

          cat > .env.prod << EOF
          CONTAINER_IMAGE=${{ inputs.image }}

          # Flask Configuration
          FLASK_ENV=${{ secrets.FLASK_ENV }}
          SECRET_KEY=${{ secrets.SECRET_KEY }}

          # Database Configuration
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}


          EOF

          echo "âœ… Environment file created"

      - name: Copy deployment files to VM
        run: |
          echo "ğŸ“ Copying deployment files to VM..."
          scp .env.prod vm:/tmp/
          scp docker-compose.yml vm:/tmp/
          echo "âœ… Files copied successfully"

      - name: Deploy application with Docker Compose
        run: |
          echo "ğŸš€ Starting deployment on VM..."
          ssh vm << 'EOF'

            # Setup deployment directory
            sudo mkdir -p /opt/habit-tracker
            sudo cp /tmp/.env.prod /opt/habit-tracker/.env
            sudo cp /tmp/docker-compose.yml /opt/habit-tracker/
            cd /opt/habit-tracker

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Stop existing services
            sudo docker compose down || true

            # Pull latest images
            sudo docker compose pull

            # Start services with environment file
            sudo docker compose --env-file .env up -d

            # Wait for services to be healthy
            echo "â³ Waiting for services to be healthy..."
            for i in {1..30}; do
              if sudo docker compose --env-file .env ps | grep -q "healthy"; then
                echo "âœ… Services are healthy"
                break
              else
                echo "â³ Waiting for services... (attempt $i/30)"
                sleep 10
              fi
            done

            # Test application
            sleep 10
            curl -f http://localhost:5000/ || exit 1
            echo "âœ… Application deployed successfully with Docker Compose!"
          EOF

      - name: Verify deployment
        run: |
          VM_IP="${{ secrets.DEPLOY_VM_IP }}"
          echo "ğŸ” Verifying deployment..."

          # Test main application
          if curl -f -s "http://$VM_IP/" >/dev/null; then
            echo "âœ… Main application is responding"
          else
            echo "âš ï¸ Main application may not be ready yet"
          fi

          echo ""
          echo "ğŸ‰ Deployment completed!"
          echo "ğŸ“‹ Application URL: http://$VM_IP/"

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa
          rm -f .env.prod
